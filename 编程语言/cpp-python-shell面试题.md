# Python/C/C++/计算机基础/图像处理基础
## static关键字作用
+ 在全局变量前加上关键字static，全局变量就定义为一个全局静态变量，全局静态变量在声明它的文件之外是不可见的，作用域范围为从定义之处开始，到文件结尾。
+ 在函数返回类型前加`static`，函数就变为静态函数，静态函数只在声明它的文件中使用，不被其他文件所用。
## C++指针和引用的区别
+ 指针有自己的内存空间，而引用只是一个别名，类似于Python浅拷贝和深拷贝的区别
+ 不存在空引用, 引用必须链接到一块合法的内存地址；
+ 一旦引用被初始化为一个对象，就不能指向另一个对象。指针可以在任何时候指向任何一个对象；
+ 引用必须在创建时被初始化。指针可以在任何时间初始化。
## C++中析构函数的作用
析构函数与构造函数对应，类的析构函数是类的一种特殊的成员函数，**它会在每次删除所创建的对象时执行**。析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。
## C++静态函数和虚函数的区别
静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销。
## ++i和i++区别
++i 先自增1，再返回，i++，先返回 i，再自增1.
## const关键字作用
`const`类型的对象在程序执行期间不能被修改改变。
## 实例方法/静态方法/类方法
`python` 类语法中有三种方法，**实例方法，静态方法，类方法**，它们的区别如下：
+ 实例方法只能被实例对象调用，静态方法(由 `@staticmethod` 装饰器来声明)、类方法(由 `@classmethod` 装饰器来声明)，可以被类或类的实例对象调用;
+ 实例方法，第一个参数必须要默认传实例对象，一般习惯用self。静态方法，参数没有要求。类方法，第一个参数必须要默认传类，一般习惯用 `cls` .

实例代码如下：
```Python
class Foo(object):
    """类三种方法语法形式
    """
    def instance_method(self):
        print("是类{}的实例方法，只能被实例对象调用".format(Foo))

    @staticmethod
    def static_method():
        print("是静态方法")

    @classmethod
    def class_method(cls):
        print("是类方法")


foo = Foo()
foo.instance_method()
foo.static_method()
foo.class_method()
print('##############')
Foo.static_method()
Foo.class_method()
```
程序执行后输出如下：
> 是类<class '__main__.Foo'>的实例方法，只能被实例对象调用
是静态方法
是类方法
##############
是静态方法
是类方法

## __new__和__init__方法的区别
+ `__init__` 方法并不是真正意义上的构造函数, `__new__` 方法才是(类的构造函数是类的一种特殊的成员函数，它会**在每次创建类的新对象时执行**);
+ `__new__` 方法用于创建对象并返回对象，当返回对象时会自动调用 `__init__` 方法进行初始化, `__new__` 方法比 `__init__` 方法更早执行;
+ `__new__` 方法是**静态方法**，而 `__init__` 是**实例方法**。
## Python的函数参数传递
> 参考这两个链接，stackoverflow的最高赞那个讲得很详细
[How do I pass a variable by reference?](https://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference)
[Python 面试题](https://github.com/taizilongxu/interview_python#python%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7)

个人总结（有点不好）：
+ 将可变对象：列表list、字典dict、NumPy数组ndarray和用户定义的类型（类），作为参数传递给函数，函数内部将其改变后，函数外部这个变量也会改变（对变量进行重新赋值除外 `rebind the reference in the method`）
+ 将不可变对象：字符串string、元组tuple、数值numbers，作为参数传递给函数，函数内部将其改变后，函数外部这个变量不会改变

## Python实现对函参做类型检查
`Python` 自带的函数一般都会有对函数参数类型做检查，自定义的函数参数类型检查可以用函数 `isinstance()` 实现，例如：
```Python
def my_abs(x):
    """
    自定义的绝对值函数
    :param x: int or float
    :return: positive number, int or float
    """
    if not isinstance(x, (int, float)):
        raise TypeError('bad operand type')
    if x > 0:
        return x
    else:
        return -x
```
添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个 `TypeError` 错误。
## 为什么说Python是动态语言
在 `Python` 中，等号 `=` 是赋值语句，可以把`任意数据类型`赋值给变量，同样一个变量可以反复赋值，而且可以是不同类型的变量，例如：
```Python
a = 100 # a是int型变量
print(a)
a = 'ABC'  # a 是str型变量
print(a)
```
Pyhon 这种变量本身类型不固定，可以反复赋值不同类型的变量称为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错，Java/C++ 都是静态语言（`int a; a = 100`）
## Python装饰器解释
装饰器本质上是一个 Python 函数或类，**它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能**，装饰器的返回值也是一个函数/类对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景，装饰器是解决这类问题的绝佳设计。有了装饰器，我们就可以**抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用**。概括的讲，**装饰器的作用就是为已经存在的对象添加额外的功能**。
## 多进程与多线程区别
+ 线程是进程的一部分，一个进程至少有一个线程；
+ 对于操作系统来说，一个任务就是一个进程，进程内的“子任务”称为线程；
+ 多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而**多线程中，所有变量都由所有线程共享**，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。
+ 进程间调用、通讯和切换开销均比多线程大，单个线程的崩溃会导致整个应用的退出。
+ 存在大量IO，网络耗时或者需要和用户交互等操作时，使用多线程有利于提高系统的并发性和用户界面快速响应从而提高友好性。
## map与reduce函数用法解释下
1. map函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的**每个元素**，并将结果作为新的Iterator返回，简单示例代码如下：
```Python3
# 示例１
def square(x):
    return x ** 2
r = map(square, [1, 2, 3, 4, 5, 6, 7])
squareed_list = list(r)
print(squareed_list)  # [1, 4, 9, 16, 25, 36, 49]
# 使用lambda匿名函数简化为一行代码
list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
# 示例２
list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))　＃　['1', '2', '3', '4', '5', '6', '7', '8', '9']
```
**注意map函数返回的是一个Iterator（惰性序列），要通过list函数转化为常用列表结构**。map()作为高阶函数，事实上它是把运算规则抽象了。

2. reduce()函数也接受两个参数，一个是函数（**两个参数**），一个是序列，与map不同的是**reduce把结果继续和序列的下一个元素做累积计算**,效果如下：
`reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)`
示例代码如下：
```Python3
from functools import reduce
CHAR_TO_INT = {
    '0': 0,
    '1': 1,
    '2': 2,
    '3': 3,
    '4': 4,
    '5': 5,
    '6': 6,
    '7': 7,
    '8': 8,
    '9': 9
}
def str2int(str):
    ints = map(lambda x:CHAR_TO_INT[x], str)  # str对象是Iterable对象
    return reduce(lambda x,y:10*x + y, ints)
print(str2int('0'))
print(str2int('12300'))
print(str2int('0012345'))  # 0012345
```
## Python深拷贝、浅拷贝区别
1. 直接赋值：其实就是对象的引用（别名）。
2. 浅拷贝(copy)：拷贝父对象，不会拷贝对象的内部的子对象。（拷贝可以理解为创建内存）可以产生浅拷贝的操作有以下几种：
    + 使用切片[:]操作
    + 使用工厂函数（如list/dir/set）,工厂函数看上去像函数，实质上是类，调用时实际上是生成了该类型的一个实例，就像工厂生产货物一样.
    + 使用copy模块中的copy()函数
3. 深拷贝(deepcopy)： copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象，两者是完全独立的。**深拷贝，包含对象里面的子对象的拷贝，所以原始对象的改变不会造成深拷贝里任何子元素的改变**。

**注意：浅拷贝和深拷贝的不同仅仅是对组合对象来说，所谓的组合对象（容器）就是包含了其它对象的对象，如列表，类实例。而对于数字、字符串以及其它“原子”类型，没有拷贝一说，产生的都是原对象的引用。**
看一个示例程序，就能明白浅拷贝与深拷贝的区别了：
```Python3
#!/usr/bin/Python3
# -*-coding:utf-8 -*-

import copy
a = [1, 2, 3, ['a', 'b', 'c']]

b = a  # 赋值，传对象的引用
c = copy.copy(a)  # 浅拷贝
d = copy.deepcopy(a)  # 深拷贝

a.append(4)
a[3].append('d')

print('a = ', a)
print('b = ', b)
print('c = ', c)
print('d = ', d)  # [1, 2, 3, ['a', 'b', 'c']]
```
程序输出如下：
> a =  [1, 2, 3, ['a', 'b', 'c', 'd'], 4]
b =  [1, 2, 3, ['a', 'b', 'c', 'd'], 4]
c =  [1, 2, 3, ['a', 'b', 'c', 'd']]
d =  [1, 2, 3, ['a', 'b', 'c']]

## 其他面试题
参考[这里](https://zhuanlan.zhihu.com/p/23526961)
